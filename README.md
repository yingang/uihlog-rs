# uihlog.exe reloaded in Rust

A utility to parse log files generated by UIH imaging devices, which is also a toy project for me to learn Rust!

## Disclaimer

There should be no UIH proprietary information that has been used in this project. Please let me know if I miss anything.

## Why

* The raw log files are organized in time order, so it's not easy to see through the event stream of any specific logging source.
* Non-printable ASCII character have been used in the raw log files, which some human readers like me don't like to see at all.
* Unix timestamp has been used in the raw log files, which, I suppose, most human reader should not be fond of.

## What

* Compact and well-organized parsing output, which enables more efficient log analysis.
* Much faster parsing speed, about 0.1 second per log file on my daily used laptop.
* Support of parsing both client-side and server-side timestamps, which makes it much easier for the tracing of events happenning between machines.
* Support of file-to-file parsing (one raw log file to one parsed log file).

## How

### Traditional Way

 * Copy `uihlog.exe` into the folder with raw log files and run it, then all the parsed log files would show up (only by log source).

### Integrated Way

* Keep `uihlog.exe` and the batch scripts under `utils` in the same folder on your computer.
* Run `install.bat` to integrate `uihlog.exe` into context menu (shell extension), which could be undone by running `uninstall.bat`.
  * Currently `Directory` and `.uihlog` are registered to enable folder parsing and file-to-file parsing.
* [Optional] Run `pid_output_enable.bat` to enable parsed output by log PID, which could be undone by running `pid_output_disable.bat`.
  * PID output is not turned on by default, since in most cases I don't need it ...
* Then you could right click on log folder or single log file to parse it!
  * It's also okay to double click the log file for file-to-file parsing.

## Future
* Fast parsing speed makes some fancy log analysis application possible? Like Just-in-Time parsing, etc.
